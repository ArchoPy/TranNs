def func(num, old_osn, new_osn): # num - число в начальной системе счисления old_osn, переводим в new_osn
    alf = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ' # алфавит, вмещающий в себя 36 символов (область работы функции - до 36 сиситемы счисления)
    number = int(num, old_osn) if isinstance(num, str) else int(str(num), old_osn) # перевод числа из текущей СС (old_osn) в 10-ую СС | isinstance просто проверяет является ли число строкой (более универсально, тк int работает только со строчными); можно убрать и просто всегда писать строчное число

    if new_osn == 10: # если конечная цель - просто перевод в 10-ую СС, то во избежание ошибок \
        return number # возвращаем переведенное число сразу

    final_num = '' # пустая строка, т.е каркас будущего числа, если цель перевода не 10-ая СС

    while number % new_osn != 0: # стандартный алгоритм перевода, пока остаток от деления не нулевой...
        number, ost = divmod(number, new_osn) # эквивалентно number = number // (div) new_osn И ost = number %(mod) new_osn. Функция заменяет две строки и возвращает два значения
        final_num += alf[ost] # пополняем каркас числа литералами из alf. Поскольку все литералы упорядочены и начинаются с нуля, то остаток будет эквивалентен числу из alf под таким же индексом

    return final_num[::-1] # читаем строку задом наперед

print(func('6784356', 10, 16))
